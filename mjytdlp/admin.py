from __future__ import annotations

import json
import os
import re
import time
from typing import Any, Dict, List

from flask import (
    Blueprint,
    Response,
    abort,
    jsonify,
    redirect,
    render_template,
    request,
    session,
    url_for,
)

from .mcp_settings import DEFAULT_MCP_SETTINGS, load_mcp_settings, save_mcp_settings
from .utils import get_data_dir


admin_bp = Blueprint("admin", __name__, url_prefix="/admin")


def _admin_password() -> str | None:
    pw = os.getenv("MJYTDLP_ADMIN_PASSWORD")
    if isinstance(pw, str) and pw.strip():
        return pw.strip()
    return None


def _admin_disabled() -> bool:
    flag = os.getenv("MJYTDLP_DISABLE_ADMIN")
    return isinstance(flag, str) and flag.strip().lower() in ("1", "true", "yes", "on")


def _require_admin_enabled() -> None:
    if _admin_disabled() or not _admin_password():
        abort(404)


def _require_ui_login() -> None:
    if not session.get("mjytdlp_admin"):
        abort(401)


def _require_api_auth() -> None:
    pw = _admin_password()
    if not pw:
        abort(404)

    header = request.headers.get("Authorization", "")
    token = ""
    if isinstance(header, str) and header.lower().startswith("bearer "):
        token = header[7:].strip()
    if not token:
        token = (request.headers.get("X-MJYTDLP-Admin-Password") or "").strip()
    if token != pw:
        abort(401)


def _mask_secret(value: str) -> str:
    if not value:
        return ""
    if len(value) <= 6:
        return "***"
    return f"{value[:2]}***{value[-2:]}"


def _cookies_path() -> str:
    return os.path.join(get_data_dir(), "cookies.txt")


def _cookies_dir() -> str:
    return os.path.join(get_data_dir(), "cookies")


def _safe_cookie_name(name: str) -> str:
    cleaned = re.sub(r"[^a-zA-Z0-9_-]", "", name).strip()
    if not cleaned:
        return ""
    if not cleaned.endswith(".txt"):
        cleaned = f"{cleaned}.txt"
    return cleaned


def _maybe_convert_cookie_json(raw_text: str) -> str | None:
    stripped = raw_text.lstrip()
    if not stripped.startswith("{") and not stripped.startswith("["):
        return None
    try:
        payload = json.loads(raw_text)
    except Exception:
        return None

    if isinstance(payload, dict):
        cookies = payload.get("cookies")
        if isinstance(cookies, list):
            payload = cookies

    if not isinstance(payload, list):
        return None

    lines = [
        "# Netscape HTTP Cookie File",
        "# This file was generated by MJYT-DLP",
    ]

    for item in payload:
        if not isinstance(item, dict):
            continue
        domain = item.get("domain") or item.get("host") or ""
        if not isinstance(domain, str) or not domain:
            continue
        host_only = item.get("hostOnly")
        if not (isinstance(host_only, bool) and host_only) and not domain.startswith("."):
            domain = f".{domain}"
        flag = "TRUE" if domain.startswith(".") else "FALSE"
        path = item.get("path") or "/"
        if not isinstance(path, str) or not path:
            path = "/"
        secure = "TRUE" if item.get("secure") else "FALSE"
        expires = item.get("expirationDate")
        if not isinstance(expires, (int, float)):
            expires = item.get("expires") if isinstance(item.get("expires"), (int, float)) else 0
        name = item.get("name") or ""
        value = item.get("value") or ""
        if not isinstance(name, str) or not name:
            continue
        if not isinstance(value, str):
            value = str(value)
        lines.append(f"{domain}\t{flag}\t{path}\t{secure}\t{int(expires)}\t{name}\t{value}")

    return "\n".join(lines) + "\n" if len(lines) > 2 else None


def _list_named_cookies() -> List[Dict[str, Any]]:
    folder = _cookies_dir()
    out: List[Dict[str, Any]] = []
    try:
        if not os.path.isdir(folder):
            return out
        for filename in os.listdir(folder):
            if not filename.endswith(".txt"):
                continue
            path = os.path.join(folder, filename)
            if not os.path.isfile(path):
                continue
            try:
                size = os.path.getsize(path)
                mtime_ts = os.path.getmtime(path)
                mtime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(mtime_ts))
            except Exception:
                size = None
                mtime = None
                mtime_ts = None
            short_name = filename[:-4] if filename.endswith(".txt") else filename
            out.append(
                {
                    "name": filename,
                    "short_name": short_name,
                    "path": path,
                    "size": size,
                    "mtime": mtime,
                    "mtime_ts": mtime_ts,
                }
            )
    except Exception:
        return out
    out.sort(key=lambda item: item.get("name") or "")
    return out


def _latest_named_cookie(named: List[Dict[str, Any]]) -> Dict[str, Any] | None:
    if not named:
        return None
    return max(named, key=lambda item: item.get("mtime_ts") or 0)


def _cookies_status() -> Dict[str, Any]:
    path = _cookies_path()
    exists = os.path.isfile(path)
    size = None
    mtime = None
    if exists:
        try:
            size = os.path.getsize(path)
            mtime = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(os.path.getmtime(path)))
        except Exception:
            pass
    named = _list_named_cookies()
    return {
        "path": path,
        "exists": exists,
        "size": size,
        "mtime": mtime,
        "list": named,
        "latest": _latest_named_cookie(named),
    }


def _cookies_notice(code: str | None) -> Dict[str, str] | None:
    mapping = {
        "uploaded": {"kind": "ok", "text": "cookies.txt 上传成功。"},
        "upload_failed": {"kind": "bad", "text": "cookies.txt 上传失败，请重试。"},
        "named_uploaded": {"kind": "ok", "text": "指定 cookies 文件上传成功。"},
        "named_upload_failed": {"kind": "bad", "text": "指定 cookies 文件上传失败。"},
        "name_invalid": {"kind": "bad", "text": "cookies 名称不合法，只能用字母/数字/下划线/短横线。"},
        "format_invalid": {"kind": "bad", "text": "cookies 格式不支持，请用 Netscape 或 Cookie-Editor JSON。"},
        "delete_failed": {"kind": "bad", "text": "cookies.txt 删除失败。"},
        "deleted": {"kind": "ok", "text": "cookies.txt 已删除。"},
        "named_deleted": {"kind": "ok", "text": "指定 cookies 文件已删除。"},
        "named_delete_failed": {"kind": "bad", "text": "指定 cookies 文件删除失败。"},
        "missing": {"kind": "bad", "text": "未找到 cookies.txt。"},
        "empty": {"kind": "bad", "text": "请选择 cookies.txt 文件。"},
    }
    return mapping.get(code or "")


def _mcp_ui_providers(settings: Dict[str, Any]) -> List[Dict[str, Any]]:
    providers = settings.get("providers") if isinstance(settings.get("providers"), list) else []
    out: List[Dict[str, Any]] = []
    for p in providers:
        if not isinstance(p, dict):
            continue
        api_key = p.get("api_key") if isinstance(p.get("api_key"), str) else ""
        out.append(
            {
                "id": p.get("id") or "",
                "label": p.get("label") or "",
                "base_url": p.get("base_url") or "",
                "endpoint_url": p.get("endpoint_url") or "",
                "model": p.get("model") or "",
                "api_key_env": p.get("api_key_env") or "",
                "api_key_masked": _mask_secret(api_key),
                "auth_header": p.get("auth_header") or "",
                "auth_prefix": p.get("auth_prefix") or "",
                "extra_headers": json.dumps(p.get("extra_headers") or {}, ensure_ascii=False, indent=2),
                "timeout": p.get("timeout") or "",
                "enabled": bool(p.get("enabled", True)),
            }
        )
    return out


@admin_bp.before_request
def _guard():
    _require_admin_enabled()


@admin_bp.get("/login")
def login_page() -> Response:
    return render_template("admin_login.html", error=None)


@admin_bp.post("/login")
def login_post() -> Response:
    pw = _admin_password() or ""
    submitted = (request.form.get("password") or "").strip()
    if submitted and submitted == pw:
        session["mjytdlp_admin"] = True
        return redirect(url_for("admin.panel"))
    return render_template("admin_login.html", error="密码不正确")


@admin_bp.post("/logout")
def logout_post() -> Response:
    session.pop("mjytdlp_admin", None)
    return redirect(url_for("admin.login_page"))


@admin_bp.get("/")
def panel() -> Response:
    if not session.get("mjytdlp_admin"):
        return redirect(url_for("admin.login_page"))

    return render_template(
        "admin_panel.html",
        home_dir=get_data_dir(),
        cookies=_cookies_status(),
        cookies_notice=_cookies_notice(request.args.get("cookies")),
    )


@admin_bp.get("/mcp")
def mcp_panel() -> Response:
    if not session.get("mjytdlp_admin"):
        return redirect(url_for("admin.login_page"))

    settings = load_mcp_settings()
    providers = _mcp_ui_providers(settings)
    return render_template(
        "admin_mcp.html",
        providers=providers,
        default_provider=settings.get("default_provider"),
        home_dir=get_data_dir(),
        error=None,
    )


@admin_bp.post("/mcp/provider")
def mcp_provider_upsert() -> Response:
    if not session.get("mjytdlp_admin"):
        return redirect(url_for("admin.login_page"))

    def _get_bool(name: str) -> bool:
        return (request.form.get(name) or "").strip().lower() in ("1", "true", "yes", "on")

    settings = load_mcp_settings()
    providers = settings.get("providers") if isinstance(settings.get("providers"), list) else []

    pid = (request.form.get("id") or "").strip()
    if not pid:
        providers_ui = _mcp_ui_providers(settings)
        return render_template(
            "admin_mcp.html",
            providers=providers_ui,
            default_provider=settings.get("default_provider"),
            home_dir=get_data_dir(),
            error="Provider id 不能为空。",
        )

    existing = next((p for p in providers if isinstance(p, dict) and p.get("id") == pid), None)

    api_key_input = (request.form.get("api_key") or "").strip()
    clear_api_key = _get_bool("clear_api_key")
    api_key = ""
    if api_key_input:
        api_key = api_key_input
    elif clear_api_key:
        api_key = ""
    elif isinstance(existing, dict):
        api_key = existing.get("api_key") or ""

    extra_headers_raw = (request.form.get("extra_headers") or "").strip()
    if extra_headers_raw:
        try:
            parsed = json.loads(extra_headers_raw)
            if not isinstance(parsed, dict):
                raise ValueError("extra_headers must be an object")
            extra_headers = parsed
        except Exception:
            providers_ui = _mcp_ui_providers(settings)
            return render_template(
                "admin_mcp.html",
                providers=providers_ui,
                default_provider=settings.get("default_provider"),
                home_dir=get_data_dir(),
                error="extra_headers 必须是合法的 JSON 对象。",
            )
    elif isinstance(existing, dict):
        extra_headers = existing.get("extra_headers") or {}
    else:
        extra_headers = {}

    timeout_raw = (request.form.get("timeout") or "").strip()
    timeout_val: Any = None
    if timeout_raw:
        try:
            timeout_val = float(timeout_raw)
        except Exception:
            timeout_val = None
    elif isinstance(existing, dict):
        timeout_val = existing.get("timeout")

    def _inherit(name: str, default: str = "") -> str:
        value = (request.form.get(name) or "").strip()
        if value:
            return value
        if isinstance(existing, dict):
            existing_val = existing.get(name)
            if isinstance(existing_val, str) and existing_val.strip():
                return existing_val.strip()
        return default

    provider_payload: Dict[str, Any] = {
        "id": pid,
        "label": _inherit("label", pid) or pid,
        "base_url": _inherit("base_url", ""),
        "endpoint_url": _inherit("endpoint_url", ""),
        "model": _inherit("model", ""),
        "api_key": api_key,
        "api_key_env": _inherit("api_key_env", ""),
        "auth_header": _inherit("auth_header", "Authorization") or "Authorization",
        "auth_prefix": _inherit("auth_prefix", "Bearer ") or "Bearer ",
        "extra_headers": extra_headers,
        "timeout": timeout_val,
        "enabled": _get_bool("enabled"),
    }

    if existing is not None:
        providers = [provider_payload if p.get("id") == pid else p for p in providers]
    else:
        providers.append(provider_payload)

    settings["providers"] = providers

    if _get_bool("set_default"):
        settings["default_provider"] = pid

    save_mcp_settings(settings)
    return redirect(url_for("admin.mcp_panel"))


@admin_bp.post("/mcp/provider/delete")
def mcp_provider_delete() -> Response:
    if not session.get("mjytdlp_admin"):
        return redirect(url_for("admin.login_page"))

    pid = (request.form.get("id") or "").strip()
    settings = load_mcp_settings()
    providers = settings.get("providers") if isinstance(settings.get("providers"), list) else []
    providers = [p for p in providers if not (isinstance(p, dict) and p.get("id") == pid)]
    settings["providers"] = providers
    if settings.get("default_provider") == pid:
        settings["default_provider"] = None
    save_mcp_settings(settings)
    return redirect(url_for("admin.mcp_panel"))


@admin_bp.post("/mcp/default")
def mcp_default_set() -> Response:
    if not session.get("mjytdlp_admin"):
        return redirect(url_for("admin.login_page"))

    pid = (request.form.get("default_provider") or "").strip()
    settings = load_mcp_settings()
    providers = settings.get("providers") if isinstance(settings.get("providers"), list) else []
    if pid and any(isinstance(p, dict) and p.get("id") == pid for p in providers):
        settings["default_provider"] = pid
    else:
        settings["default_provider"] = None
    save_mcp_settings(settings)
    return redirect(url_for("admin.mcp_panel"))


@admin_bp.get("/api/mcp/settings")
def api_get_mcp_settings() -> Response:
    _require_api_auth()
    return jsonify(load_mcp_settings())


@admin_bp.post("/api/mcp/settings")
def api_set_mcp_settings() -> Response:
    _require_api_auth()
    payload = request.get_json(silent=True) or {}
    if not isinstance(payload, dict):
        abort(400)
    merged = {**DEFAULT_MCP_SETTINGS, **payload}
    if not save_mcp_settings(merged):
        abort(500)
    return jsonify({"ok": True, "settings": load_mcp_settings()})


@admin_bp.post("/yt-dlp/cookies")
def cookies_upload() -> Response:
    if not session.get("mjytdlp_admin"):
        return redirect(url_for("admin.login_page"))

    file = request.files.get("cookies_file")
    if file is None or not file.filename:
        return redirect(url_for("admin.panel", cookies="empty"))

    name = (request.form.get("cookies_name") or "").strip()
    if name:
        safe_name = _safe_cookie_name(name)
        if not safe_name:
            return redirect(url_for("admin.panel", cookies="name_invalid"))
        target = os.path.join(_cookies_dir(), safe_name)
        notice = "named_uploaded"
        failure = "named_upload_failed"
    else:
        target = _cookies_path()
        notice = "uploaded"
        failure = "upload_failed"
    try:
        os.makedirs(os.path.dirname(target), exist_ok=True)
        raw = file.read()
        if not raw:
            return redirect(url_for("admin.panel", cookies="empty"))
        text = raw.decode("utf-8", errors="ignore")
        converted = _maybe_convert_cookie_json(text)
        if converted is None and (file.filename.endswith(".json") or file.filename.endswith(".js")):
            return redirect(url_for("admin.panel", cookies="format_invalid"))
        if converted is not None:
            with open(target, "w", encoding="utf-8") as fp:
                fp.write(converted)
        else:
            with open(target, "wb") as fp:
                fp.write(raw)
        try:
            os.chmod(target, 0o600)
        except Exception:
            pass
        return redirect(url_for("admin.panel", cookies=notice))
    except Exception:
        return redirect(url_for("admin.panel", cookies=failure))


@admin_bp.post("/yt-dlp/cookies/delete")
def cookies_delete() -> Response:
    if not session.get("mjytdlp_admin"):
        return redirect(url_for("admin.login_page"))

    name = (request.form.get("cookies_name") or "").strip()
    if name:
        safe_name = _safe_cookie_name(name)
        if not safe_name:
            return redirect(url_for("admin.panel", cookies="name_invalid"))
        target = os.path.join(_cookies_dir(), safe_name)
        deleted_code = "named_deleted"
        missing_code = "missing"
        failure_code = "named_delete_failed"
    else:
        target = _cookies_path()
        deleted_code = "deleted"
        missing_code = "missing"
        failure_code = "delete_failed"
    try:
        os.remove(target)
        return redirect(url_for("admin.panel", cookies=deleted_code))
    except FileNotFoundError:
        return redirect(url_for("admin.panel", cookies=missing_code))
    except Exception:
        return redirect(url_for("admin.panel", cookies=failure_code))
